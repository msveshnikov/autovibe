import express from 'express';
import { exec } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Helper to get __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(express.json());
// Serve static files (index.html, css, js, images)
app.use(express.static(path.join(__dirname, '.')));

// Function to call Google Gemini Flash model
const callGeminiFlash = async (seed, apiKey) => {
    if (!apiKey) {
        throw new Error('API Key is required to call the Gemini model.');
    }
    try {
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-thinking-exp-01-21' });

        const result = await model.generateContent(seed);
        // Handle potential content filtering or lack of response
        if (
            !result.response ||
            !result.response.candidates ||
            result.response.candidates.length === 0 ||
            !result.response.candidates[0].content ||
            !result.response.candidates[0].content.parts ||
            result.response.candidates[0].content.parts.length === 0
        ) {
            // Check for safety ratings if available
            const safetyFeedback = result.response?.promptFeedback;
            if (safetyFeedback?.blockReason) {
                throw new Error(
                    `Content generation blocked due to: ${safetyFeedback.blockReason}. Details: ${JSON.stringify(safetyFeedback.safetyRatings)}`
                );
            }
            throw new Error('No content generated by the model.');
        }
        // Assuming the response structure holds text in the first part
        const text = result.response.candidates[0].content.parts[0].text;
        if (typeof text !== 'string') {
            throw new Error('Received unexpected response format from Gemini API.');
        }
        return text;
    } catch (error) {
        console.error('Gemini API Error:', error);
        // Check for specific API-related errors if needed
        if (error.message.includes('API key not valid')) {
            throw new Error(`Gemini API execution failed: Invalid API Key. Please check your key.`);
        }
        if (error.message.includes('Content generation blocked')) {
            throw error; // Re-throw specific block reason
        }
        throw new Error(`Gemini API execution failed: ${error.message}`);
    }
};

// Function to call AutoCode CLI (placeholder for iterative logic)
const callAutoCodeCLI = (seed) =>
    new Promise((resolve, reject) => {
        // Basic input sanitization for shell command
        const sanitizedSeed = seed.replace(/"/g, '\\"').replace(/`/g, '\\`').replace(/\$/g, '\\$'); // Basic sanitization
        // In a real scenario, consider more robust sanitization or alternative execution methods
        // Ensure AutoCode CLI is installed or use npx
        const command = `autocode generate "${sanitizedSeed}"`; // Assuming 'autocode' is in PATH or use 'npx autocode-ai generate ...'
        console.log(`Executing AutoCode CLI: ${command}`);
        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error(`AutoCode CLI Error: ${stderr || error.message}`);
                // Don't reject the promise here, return an error message in the result
                resolve(`AutoCode CLI execution failed: ${stderr || error.message}`);
            } else {
                resolve(stdout.trim());
            }
        });
    });

// Core thinking loop logic
const runThinkingLoop = async (seed, apiKey, iterationCount = 5) => {
    console.log(
        `Starting loop for seed: "${seed}" with ${iterationCount} iterations. API Key provided: ${!!apiKey}`
    );

    const results = [];
    let currentSeed = seed; // Use the original seed for the first iteration

    for (let i = 1; i <= iterationCount; i++) {
        console.log(`Running iteration ${i} with seed length: ${currentSeed.length}`); // Log length instead of full seed if it gets too long
        try {
            // Call Gemini Flash model in each iteration
            const geminiResult = await callGeminiFlash(currentSeed, apiKey);

            // Store the result for this iteration
            results.push({ iteration: i, output: geminiResult });

            // Update the seed for the next iteration by appending the result
            // Consider alternative strategies if context window becomes an issue
            currentSeed += '\n' + geminiResult;
        } catch (err) {
            console.error(`Error during iteration ${i}:`, err);
            results.push({ iteration: i, error: `Iteration failed: ${err.message}` });
            // Decide if loop should continue or break on error
            // Break if API key is invalid or other critical errors occur
            if (
                err.message.includes('Invalid API Key') ||
                err.message.includes('API Key is required') ||
                err.message.includes('Content generation blocked') // Stop if content is blocked
            ) {
                console.warn(`Stopping loop early due to critical error: ${err.message}`);
                break;
            }
            // Continue for other errors, logging them per iteration
        }
    }
    console.log(`Loop finished for seed: "${seed}"`);
    return results;
};

// API endpoint to trigger the thinking loop
app.post('/api/loop', async (req, res) => {
    const authHeader = req.header('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
            message: 'Unauthorized: Missing or invalid API key format. Use Bearer token.'
        });
    }
    const apiKey = authHeader.split(' ')[1];
    if (!apiKey) {
        // This check might be redundant given the previous one, but ensures apiKey is not empty
        return res.status(401).json({ message: 'Unauthorized: Missing API key.' });
    }

    const { seed, iterationCount } = req.body;

    if (!seed || typeof seed !== 'string' || !seed.trim()) {
        return res.status(400).json({
            message: 'Bad Request: Missing or invalid "seed" input (must be a non-empty string).'
        });
    }

    const count = parseInt(iterationCount, 10);
    // Keep default/max iterations reasonable
    const finalIterationCount = isNaN(count) || count <= 0 ? 5 : Math.min(count, 20); // Default 5, max 20 (adjust as needed)

    try {
        const results = await runThinkingLoop(seed.trim(), apiKey, finalIterationCount);
        // Check if the loop ended early due to an API key error or content block
        const criticalError = results.find(
            (r) =>
                r.error &&
                (r.error.includes('Invalid API Key') ||
                    r.error.includes('API Key is required') ||
                    r.error.includes('Content generation blocked'))
        );
        if (criticalError) {
            // Return appropriate status code based on error
            const status = criticalError.error.includes('API Key') ? 401 : 400; // 401 for Auth, 400 for Content Block
            return res.status(status).json({ message: criticalError.error, results });
        }
        res.json({ results });
    } catch (error) {
        // Catch potential errors not caught within the loop (e.g., setup issues)
        console.error('Error in /api/loop handler:', error);
        // Distinguish between client errors (like bad API key detected early) and server errors
        if (error.message.includes('API Key is required')) {
            return res.status(401).json({ message: 'Unauthorized: ' + error.message });
        }
        res.status(500).json({ message: 'Internal Server Error', error: error.toString() });
    }
});

// Serve index.html for the root route
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Catch-all for serving other static files if needed (though express.static should handle it)
// Optional: Add specific routes for CSS/JS if needed, but static middleware is generally sufficient.

// Start the server
app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});